# -*- coding: utf-8 -*-
"""StockPrediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15DdSeocIBpLFOGDeFfyh-V-3QEs7M-vj
"""

!pip install yfinance

!pip install altair_viewer

import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

try:
    df = yf.download("TSLA", start="2010-01-01", end="2023-12-31")

    # Calculate a 50-day moving average
    df["MA_50"] = df["Adj Close"].rolling(window=50).mean()

    # Plotting
    plt.figure(figsize=(12, 6))
    plt.plot(df["Adj Close"], label="TSLA")
    plt.plot(df["MA_50"], label="50-day MA")
    plt.xlabel("Date")
    plt.ylabel("Adjusted Closing Price")
    plt.title("TSLA Stock Price with 50-day Moving Average")
    plt.legend()
    plt.show()

except Exception as e:
    print(f"Error downloading data: {e}")

df.info()

df.head()

adj_close_series = df['Adj Close']
print(adj_close_series.head().to_markdown(numalign='left', stralign='left'))  # Print first 5 values

"""# Per hour data"""

import requests
import pandas as pd

API_KEY = 'JCSNW8TJCWZLU5ML'
SYMBOL = 'AAPL'

url = f'https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol={SYMBOL}&interval=60min&apikey={API_KEY}&outputsize=full'
response = requests.get(url)
data = response.json()

# Extract the relevant time series data
time_series = data['Time Series (60min)']

# Create a DataFrame from the time series data
df = pd.DataFrame(time_series).transpose()

# Convert index to datetime for easier manipulation
df.index = pd.to_datetime(df.index)
# Rename the columns
df.columns = ['open', 'high', 'low', 'close', 'volume']

# Convert the columns to float64 datatype.
for i in df.columns:
  df[i] = df[i].astype(float)

# Print the first 5 rows
print(df.head().to_markdown(numalign='left', stralign='left'))

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))  # Adjust the size if needed
plt.plot(df.index, df['close'], label='Close Price')  # Plotting the closing prices against the datetime index
plt.xlabel('Time')
plt.ylabel('Closing Price')
plt.title('AAPL Closing Price (1-Hour Intervals)')
plt.legend()  # Show the legend
plt.grid(axis='y', alpha=0.75) # Show the y axis grid
plt.show()

"""Price changes (both absolute and percentage) are fundamental indicators of how the stock is performing in the short term. Large changes might signal significant market movements."""

df['price_change'] = df['close'] - df['close'].shift(1)
df['price_change_pct'] = (df['close'] - df['close'].shift(1)) / df['close'].shift(1) * 100

"""Past prices can be used as predictors of future prices. For example, a sudden drop in price 3 hours ago might influence the current price."""

for i in range(1, 4):  # Create lags for 1, 2, and 3 hours ago
   df[f'close_lag_{i}'] = df['close'].shift(i)

"""Volatility is a key indicator of market risk. High volatility might suggest a greater potential for both large gains and losses."""

df['volatility'] = df['close'].rolling(window=10).std()

# Select the relevant columns and display in a markdown table
columns_to_display = ['close', 'price_change', 'price_change_pct', 'volatility']

# Convert the percentage change column to string and add % sign to the values.
df['price_change_pct'] = df['price_change_pct'].astype(str) + ' %'

print(df[columns_to_display].head().to_markdown(numalign='left', stralign='left',floatfmt='.2f'))

print(df.head().to_markdown(numalign='left', stralign='left'))

"""# ARIMA
p (AR order): The number of past values used for the autoregressive part.

d (Differencing order): The number of times the data is differenced to achieve stationarity.

q (MA order): The number of past errors used for the moving average part.
"""

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

train_size = int(len(df) * 0.8)  # 80% for training
train, test = df[:train_size], df[train_size:]

# Assuming you've determined the optimal order (p, d, q) to be (5, 1, 0)
model = ARIMA(train['close'], order=(5, 1, 0))
model_fit = model.fit()

predictions = model_fit.forecast(steps=len(test))

mse = mean_squared_error(test['close'], predictions)
print(f"MSE: {mse}")